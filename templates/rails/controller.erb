<% 
default_namefield = nil

table_info['columns'].each_pair do |name,column| 
  # get the name of the first field that is not called 'id' as default  
  if default_namefield.nil? && name != 'id' && name !~ /_id/  
    # use this column unless it is the id primary key or a foreign key
    default_namefield = column
  end 
end 
namefield = table_info['columns']['name'] || table_info['columns']['title'] || default_namefield
%>

class <%= controller_name %> < ApplicationController
  before_action :set_<%= singular_table_name %>, only: [:show, :edit, :update, :destroy, :related]
 
  respond_to :html, :json
  
  ##### actions useful for an api   
  FIELDS = <%= table_info['columns'].keys.to_s %>
  
  # get the fields for a table
  def fields    
    respond_with(FIELDS)
  end
  
  # get a named range from a table
  def range     
    @values = <%= model_name %>.find_each.collect{|item| [item.id,item.<%= namefield['column_name'] %>]}
    respond_with(@values)
  end
 
  # get the records that are related to an object instance by the named relation
  # works for belongs_to, has_one and has_many relationships 
  # we use Rails magic in the model to specify the relation 
  def related   
    @values = @<%= singular_table_name %>.send(params['relation'].to_sym)
    respond_with(@values)
  end
  
  # perform a search
  def search
    # convert JSON string to hash and verify column names
    conditions = ActiveSupport::JSON.decode(params[:where]).keep_if{|k,v| FIELDS.include?(k)}
    
    @<%= plural_table_name %> = <%= model_name %>.where(conditions)
   
    @<%= plural_table_name %> = @<%= plural_table_name %>.order(params[:order]) unless params[:order].nil?
   
    @<%= plural_table_name %> = @<%= plural_table_name %>.limit(params[:limit]) unless params[:limit].nil?
   
    @<%= plural_table_name %> = @<%= plural_table_name %>.offset(params[:offset]) unless params[:offset].nil?
    respond_with(@<%= plural_table_name %>)
  end
 
 #############  standard Rails actions
 
  # GET /<%= plural_table_name %>
  # GET /<%= plural_table_name %>.json
  def index
    @<%= plural_table_name %> = <%= model_name %>.all
    respond_with(@<%= plural_table_name %>)
  end

  # GET /<%= plural_table_name %>/1
  # GET /<%= plural_table_name %>/1.json
  def show
    respond_with(@<%= singular_table_name %>)
  end

  # GET /<%= plural_table_name %>/new
  def new
    @<%= singular_table_name %> = <%= model_name %>.new
    respond_with(@<%= singular_table_name %>)
  end

  # GET /<%= plural_table_name %>/1/edit
  def edit
    respond_with(@<%= singular_table_name %>)
  end

  # POST /<%= plural_table_name %>
  # POST /<%= plural_table_name %>.json
  def create
    @<%= singular_table_name %> = <%= model_name %>.new(<%= singular_table_name %>_params)
    @<%= singular_table_name %>.save
    respond_with(@<%= singular_table_name %>)
  end

  # PATCH/PUT /<%= plural_table_name %>/1
  # PATCH/PUT /<%= plural_table_name %>/1.json
  def update
    @<%= singular_table_name %>.update(<%= singular_table_name %>_params)
    respond_with(@<%= singular_table_name %>)
  end

  # DELETE /<%= plural_table_name %>/1
  # DELETE /<%= plural_table_name %>/1.json
  def destroy
    @<%= singular_table_name %>.destroy
    respond_with(@<%= singular_table_name %>)
  end
 
  private
    # Use callbacks to share common setup or constraints between actions.
    
    # load the identified instance
    def set_<%= singular_table_name %>
      @<%= singular_table_name %> = <%= model_name %>.find(params[:id])
    end

    #  only allow the white listed params through.
    def <%= singular_table_name %>_params
    <% 
      column_symbols = []
      table_info['columns'].keys.reject{|key| ['created_at','updated_at','id'].include? key}.each do |key | 
        column_symbols << ":#{key}"
      end
    %>
      params.require(:<%= singular_table_name %>).permit( <%= column_symbols.join(', ') %>)
    end
end